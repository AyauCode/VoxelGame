using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Concurrent;
using UnityEngine.Profiling;
using System.ComponentModel;

public class TerrainChunk : MonoBehaviour
{
    //A 3D chunk index
    public Vector3Int chunkCoord;
    //A 3D chunk position in world space
    public Vector3 chunkWorldPos;
    //Chunk world scale
    public Vector3Int chunkSize;

    public Material terrainMat;
    //Mesh components
    MeshRenderer meshRenderer;
    MeshFilter meshFilter;
    MeshCollider meshCollider;

    //Chunk data container (used to pass chunk information between threads)
    ChunkData chunkData;

    //True if chunk mesh is generated, otherwise false
    public bool generated = false;

    Mesh chunkMesh;

    static List<Vector3> vertices = new List<Vector3>();
    static List<int> triangles = new List<int>();
    static List<Color> colors = new List<Color>();
    static Dictionary<Vector3, List<Vector3Int>> faces = new Dictionary<Vector3, List<Vector3Int>>();
    public static void InitFaces()
    {
        foreach (Vector3 dir in CustomMath.directions)
        {
            List<Vector3Int> posList = new List<Vector3Int>();
            faces.Add(dir, posList);
        }
    }
    public static void AddFace(Vector3 dir, Vector3Int pos)
    {
        faces[dir].Add(pos);
    }
    void Awake()
    {
        //Get the mesh components from the chunk game object
        meshRenderer = GetComponent<MeshRenderer>();
        meshFilter = GetComponent<MeshFilter>();
        meshCollider = GetComponent<MeshCollider>();
    }
    public void InstantiateChunkData(int byteArrayLength, NoiseSettings settings)
    {
        chunkData = new ChunkData(Vector3Int.zero, Vector3.zero, Vector3Int.zero, byteArrayLength, null);
        chunkData.settings = settings;
        chunkMesh = new Mesh();
    }
    /// <summary>
    /// Get the local position of the given world space position relative to this chunk
    /// </summary>
    /// <param name="pos">A 3D point in World Space</param>
    /// <returns>A 3D point in local space (floored to integers)</returns>
    public Vector3Int GetLocalPosition(Vector3 pos)
    {
        return Vector3Int.FloorToInt(pos - this.chunkWorldPos);
    }
    /// <summary>
    /// Get the byte value at the given 3D point
    /// </summary>
    /// <param name="pos">A 3D point in world or local space</param>
    /// <param name="isLocalPoint">Pass true if pos parameter is in local space, otherwise false</param>
    /// <returns>The byte value of the block at the given position</returns>
    public byte GetBlockByteValue(Vector3Int pos, bool isLocalPoint)
    {
        //If we are a local point (i.e. 0 <= pos < scale in all directions)
        if (isLocalPoint)
        {
            //Get the byte value at the position
            byte outByte = chunkData.GetByteValue(GetByteArrayIndex(pos, chunkSize));

            //If the chunk has saved data at this position override the byte value generated by the terrain noise
            if (chunkData.savedData != null && chunkData.savedData.HasByte(pos))
            {
                outByte = chunkData.savedData.GetByte(pos);
            }
            return outByte;
        }
        else
        {
            //If we are here we are not a local point, convert the world space position to local space
            Vector3Int localPos = GetLocalPosition(pos);

            //Get the byte value a the local space position
            byte outByte = chunkData.GetByteValue(GetByteArrayIndex(localPos, chunkSize));

            //If the chunk has saved data at this position override the byte value generated by the terrain noise
            if(chunkData.savedData != null && chunkData.savedData.HasByte(localPos))
            {
                outByte = chunkData.savedData.GetByte(localPos);
            }
            return outByte;
        }
    }
    public void FinishMesh()
    {
        chunkMesh.Clear();
        chunkMesh.vertices = chunkData.vertexArray;
        chunkMesh.triangles = chunkData.triangleArray;
        chunkMesh.colors = chunkData.colorArray;

        chunkMesh.RecalculateNormals();
        UpdateMesh(chunkMesh);

        generated = true;
        this.gameObject.SetActive(true);
    }
    /// <summary>
    /// Clear the chunk of all current data, cancel any running threads, set chunk to be ungenerated
    /// </summary>
    public void ClearChunk()
    {
        generated = false;

        if (chunkData != null)
        {
            chunkData.Reset();
        }
    }
    /// <summary>
    /// Begin generation of the chunk mesh.
    /// If chunk had previous data, clear it. Start thread to generate byte values at each block from octave noise.
    /// </summary>
    /// <param name="chunkCoord">A 3D chunk index</param>
    /// <param name="chunkWorldPos">A 3D chunk position in world space</param>
    /// <param name="settings">A NoiseSettings struct containing the values to use for the octave noise</param>
    /// <param name="savedData">The saved data for this chunk</param>
    public void PrepareChunk(Vector3Int chunkCoord, Vector3 chunkWorldPos, SavedChunkData savedData)
    {
        ClearChunk();
        this.chunkCoord = chunkCoord;
        this.chunkWorldPos = chunkWorldPos;

        chunkData.chunkCoord = chunkCoord;
        chunkData.chunkWorldPos = chunkWorldPos;
        chunkData.chunkSize = chunkSize;
        chunkData.savedData = savedData;
    }
    public void GenerateChunk()
    {
        FullGenerate(chunkData);
    }
    public static void FullGenerate(object state)
    {
        vertices.Clear();
        triangles.Clear();
        colors.Clear();
        foreach (Vector3 dir in CustomMath.directions)
        {
            faces[dir].Clear();
        }
        ChunkData chunkData = (ChunkData)state;
        GenerateByteArray(chunkData);

        if (chunkData.empty) { return; }
        GenerateMeshGreedyFace(chunkData);
        TerrainHandler.meshQueue.Enqueue(chunkData.chunkCoord);
    }
    /// <summary>
    /// Generate the byte values for a chunk.
    /// </summary>
    /// <param name="sender">The BackgroundWorker invoking this method</param>
    /// <param name="e">Parameter to share ChunkData object information between threads</param>
    public static void GenerateByteArray(object state)
    {
        //Get the chunk data from the worker argument passed on the method call.
        ChunkData chunkData = (ChunkData)state;
        chunkData.LOD = 1;
        if (Mathf.Abs(chunkData.chunkCoord.x) >= 4 && Mathf.Abs(chunkData.chunkCoord.z) >= 4)
        {
            chunkData.LOD = 3;
        }
        //Loop over all local positions (in the x,y, and z directions)
        Vector3 pos = Vector3.zero;
        int blockCount = chunkData.byteArr.Length;
        Parallel.For(0, blockCount, index =>
        {
            //Convert the 3D local space coordinate to an index to access a 1D array of byte values
            Vector3 pos = GetPositionFromIndex(index, chunkData.chunkSize);
            //Generate the byte value at the world space position of the block, with current noise settings
            //Set the byte value at the index, to the generated value
            byte val = GenerateBlock((chunkData.chunkWorldPos + pos) / chunkData.LOD);
            chunkData.SetByteValue(index, val);
        });
    }
    public static void GenerateMeshGreedyFace(object state)
    {
        ChunkData chunkData = (ChunkData)state;
        GenerateMesh(state);
        foreach(Vector3 dir in CustomMath.directions)
        {
            HashSet<Vector3Int> visited = new HashSet<Vector3Int>();

            List<Vector3Int> facesList = faces[dir];
            Vector3Int[] wlDir = CustomMath.intDirectionDictionary[dir];
            foreach(Vector3Int intPos in facesList)
            {
                if(visited.Contains(intPos)) { continue; }
                int width = 1, length = 1;
                Vector3Int checkPos = intPos + wlDir[0];
                while (WithinChunkBoundsPlusOne(checkPos, chunkData.chunkSize))
                {
                    if (!visited.Contains(checkPos) && facesList.Contains(checkPos))
                    {
                        width++;
                        visited.Add(checkPos);
                    }
                    else
                    {
                        break;
                    }
                    checkPos += wlDir[0];
                }
                checkPos = intPos + wlDir[1];
                while(WithinChunkBoundsPlusOne(checkPos, chunkData.chunkSize))
                {
                    bool rowAllowed = true;

                    int tempWidth = 0;
                    while (tempWidth < width)
                    {
                        checkPos = intPos + wlDir[0] * tempWidth + wlDir[1] * length;
                        if (!visited.Contains(checkPos) && facesList.Contains(checkPos))
                        {
                            
                        }
                        else
                        {
                            rowAllowed = false;
                            break;
                        }
                        tempWidth++;
                    }
                    if (rowAllowed)
                    {
                        tempWidth = 0;
                        while (tempWidth < width)
                        {
                            checkPos = intPos + wlDir[0] * tempWidth + wlDir[1] * length;
                            visited.Add(checkPos);

                            tempWidth++;
                        }

                        length++;
                    }
                    else
                    {
                        break;
                    }
                    checkPos = intPos + wlDir[1] * length;
                }
                AddQuad(vertices, triangles, intPos, wlDir[0], width, wlDir[1], length, dir);
                if(chunkData.LOD != 1)
                {
                    for (int c = 0; c < 4; c++)
                    {
                        colors.Add(Color.red);
                    }
                }
                else
                {
                    for(int c = 0; c < 4; c++)
                    {
                        colors.Add(Color.green);
                    }
                }
                visited.Add(intPos);
            }
        }
        chunkData.vertexArray = vertices.ToArray();
        chunkData.triangleArray = triangles.ToArray();
        chunkData.colorArray = colors.ToArray();
        chunkData.jobComplete = true;
    }
    public static bool WithinChunkBounds(Vector3 pos, Vector3 chunkSize)
    {
        return pos.x >= 0 && pos.x < chunkSize.x && pos.y >= 0 && pos.y < chunkSize.y && pos.z >= 0 && pos.z < chunkSize.z;
    }
    public static bool WithinChunkBoundsPlusOne(Vector3 pos, Vector3 chunkSize)
    {
        return pos.x >= -1 && pos.x < chunkSize.x+1 && pos.y >= -1 && pos.y < chunkSize.y+1 && pos.z >= -1 && pos.z < chunkSize.z+1;
    }

    /// <summary>
    /// Generate the chunk mesh from the generate byte values
    /// </summary>
    /// <param name="sender">The BackgroundWorker invoking this method</param>
    /// <param name="e">Parameter to share ChunkData object information between threads</param>
    public static void GenerateMesh(object state)
    {
        //Get the chunk data from the worker argument passed on the method call.
        ChunkData chunkData = (ChunkData)state;
        
        //Loop over all local space positions
        Vector3 pos = Vector3.zero;
        Vector3Int intPos = Vector3Int.zero;
        for (int i = 0; i < chunkData.chunkSize.x; i++)
        {
            for (int k = 0; k < chunkData.chunkSize.z; k++)
            {
                for (int j = 0; j < chunkData.chunkSize.y; j++)
                {
                    pos.Set(i, j, k);
                    intPos.Set(i, j, k);
                    //Check if saved block is actually an air block, if so continue to the next block
                    if (chunkData.GetByteValue(intPos) == 0)
                    {
                        continue;
                    }
                    //If we are here then the current block is solid
                    //Loop over each direction
                    for (int dIndex = 0; dIndex < CustomMath.NUMDIRECTIONS; dIndex++)
                    {
                        Vector3 dir = CustomMath.directions[dIndex];
                        //Get the block adjacent to the current block in the given direction
                        Vector3 surrounding = pos + dir;
                        //Get the calculate adjacent vector as an integer vector
                        Vector3Int surroundingInt = intPos + CustomMath.intDirections[dIndex];
                        
                        //If the calculated adjacent block is inside the bounds of this chunk continue into this if
                        if (WithinChunkBounds(surrounding, chunkData.chunkSize))
                        {
                            //If the block adjacent to the current block is air then construct a cube face in its direction
                            if (chunkData.GetByteValue(surroundingInt) == 0)
                            {
                                //Array of directions for constructing the cube face with quad normal = dir
                                Vector3Int[] wlDir = CustomMath.intDirectionDictionary[dir];
                                //Add a quad to the current vertices and triangles of the chunk, with width and length relative to the quad normal
                                //AddQuad(chunkData.vertices, chunkData.triangles, pos + wlDir[2], wlDir[0], wlDir[1], dir);
                                AddFace(dir, intPos + wlDir[2]);
                            }
                        }
                        //Else if the block is outside the current chunk bounds quickly generate the value the block would have in the next chunk
                        //Or if the chunk has saved data about the adjacent block outside the bounds and that block is air construct a face in its direction
                        //NOTE: the chunk saved data will contain information about blocks outside of the chunk bounds due to how saved information is added to the chunks
                        else if(chunkData.GetSurroundingByte(surroundingInt) == 0)
                        {
                            //Array of directions for constructing the cube face with quad normal = dir
                            Vector3Int[] wlDir = CustomMath.intDirectionDictionary[dir];
                            //Add a quad to the current vertices and triangles of the chunk, with width and length relative to the quad normal
                            //AddQuad(chunkData.vertices, chunkData.triangles, pos + wlDir[2], wlDir[0], wlDir[1], dir);
                            AddFace(dir, intPos + wlDir[2]);
                        }
                    }
                }
            }
        }
    }
    /// <summary>
    /// Set the chunk mesh filter and collider to use the given mesh
    /// </summary>
    /// <param name="mesh">A completed chunk mesh</param>
    void UpdateMesh(Mesh mesh)
    {
        meshFilter.sharedMesh = mesh;
        if (mesh.vertexCount > 0)
        {
            meshCollider.sharedMesh = mesh;
        }
        else
        {
            meshCollider.sharedMesh = null;
        }
    }
    static float vOffset = 0.001f;
    /// <summary>
    /// Adds vertices and triangle indices for a quad to the given vertex/triangle list
    /// </summary>
    /// <param name="vertices">A list of vertices of the chunk mesh</param>
    /// <param name="triangles">A list of triangle indices of the chunk mesh</param>
    /// <param name="pos">A 3D point in world space (bottom left corner of the quad)</param>
    /// <param name="widthDir">Direction of width for quad</param>
    /// <param name="lengthDir">Direction of length for quad</param>
    /// <param name="normal">Normal vector of quad face</param>
    public static void AddQuad(List<Vector3> vertices, List<int> triangles, Vector3 pos, Vector3 widthDir, Vector3 lengthDir, Vector3 normal)
    {
        //Calculate top and bottom left, right vertex positions based on given direction vectors
        Vector3 vBottomLeft = Vector3.zero, vBottomRight = Vector3.zero, vTopLeft = Vector3.zero, vTopRight = Vector3.zero;
        vBottomLeft = pos - widthDir*vOffset - lengthDir*vOffset;
        vBottomRight = pos + widthDir + widthDir * vOffset - lengthDir*vOffset;
        vTopLeft = pos + lengthDir - widthDir * vOffset + lengthDir * vOffset;
        vTopRight = pos + widthDir + lengthDir + widthDir*vOffset + lengthDir*vOffset;

        //If normal vector is left or forward flip the triangle to render on correct side (related to winding order)
        int vIndex = vertices.Count;
        if (normal == Vector3.left || normal == Vector3.forward || normal == Vector3.down)
        {
            //Add the triangle indices to the list in a counter-clockwise order
            triangles.Add(vIndex);
            triangles.Add(vIndex + 1);
            triangles.Add(vIndex + 2);

            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 1);
            triangles.Add(vIndex + 3);
        }
        else
        {
            //Add the triangle indices to the list in a clockwise order
            triangles.Add(vIndex);
            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 1);

            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 3);
            triangles.Add(vIndex + 1);
        }

        //Add the calculated vertices to the vertex list
        vertices.Add(vBottomLeft);
        vertices.Add(vBottomRight);
        vertices.Add(vTopLeft);
        vertices.Add(vTopRight);
    }
    public static void AddQuad(List<Vector3> vertices, List<int> triangles, Vector3 pos, Vector3 widthDir, float width, Vector3 lengthDir, float length, Vector3 normal)
    {
        //Calculate top and bottom left, right vertex positions based on given direction vectors
        Vector3 vBottomLeft = Vector3.zero, vBottomRight = Vector3.zero, vTopLeft = Vector3.zero, vTopRight = Vector3.zero;
        vBottomLeft = (pos) - widthDir * vOffset - lengthDir * vOffset;
        vBottomRight = (pos + widthDir * width) + widthDir * vOffset - lengthDir * vOffset;
        vTopLeft = (pos + lengthDir * length) - widthDir * vOffset + lengthDir * vOffset;
        vTopRight = (pos + widthDir*width + lengthDir*length) + widthDir * vOffset + lengthDir * vOffset;

        //If normal vector is left or forward flip the triangle to render on correct side (related to winding order)
        int vIndex = vertices.Count;
        if (normal == Vector3.left || normal == Vector3.forward || normal == Vector3.down)
        {
            //Add the triangle indices to the list in a counter-clockwise order
            triangles.Add(vIndex);
            triangles.Add(vIndex + 1);
            triangles.Add(vIndex + 2);

            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 1);
            triangles.Add(vIndex + 3);
        }
        else
        {
            //Add the triangle indices to the list in a clockwise order
            triangles.Add(vIndex);
            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 1);

            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 3);
            triangles.Add(vIndex + 1);
        }

        //Add the calculated vertices to the vertex list
        vertices.Add(vBottomLeft);
        vertices.Add(vBottomRight);
        vertices.Add(vTopLeft);
        vertices.Add(vTopRight);
    }
    /// <summary>
    /// Generate the byte value at the given world position with the current NoiseSettings
    /// </summary>
    /// <param name="pos">A 3D point in world space</param>
    /// <param name="settings">A NoiseSettings struct containing the settings for the octave noise</param>
    /// <returns>A byte value (0 for air, 1 for a solid block)</returns>
    public static byte GenerateBlock(Vector3 pos)
    {
        byte output = 0;
        //Get layered noise value at the world position with current settings, subtracting block pos.y
        //NOTE: subtracting pos.y is done to create a flat plane near y = 0
        //float val = -pos.y + LayeredNoise(pos, settings, settings.fastNoise);
        float val = -pos.y + LayeredNoise(pos);
        //If the value is greater than the air block cutoff it is a solid block (set the output to 1)
        if(val > 70f)
        {
            output = 1;
        }
        
        return output;
    }
    static bool SuperEval3D(float m, float n1, float n2, float n3, float x, float y, float z, float size, float error)
    {
        y -= 20f;
        z -= 20f;
        float pointR = Mathf.Sqrt(x * x + y * y + z * z);
        float theta = Mathf.Atan2(y, x);
        float phi = Mathf.Asin(z / (pointR));

        float r1 = SuperEval2D(theta, 5,0.1f,1.7f,1.7f);
        float r2 = SuperEval2D(phi, 1,0.3f,0.5f,0.5f);

        float x1 = (r1 * Mathf.Cos(theta) * r2 * Mathf.Cos(phi) * size);
        float y1 = (r1 * Mathf.Sin(theta) * r2 * Mathf.Cos(phi) * size);
        float z1 = (r2 * Mathf.Sin(phi) * size);
        float r = Mathf.Sqrt(x1 * x1 + y1 * y1 + z1 * z1);

        return pointR < r;
    }
    static float SuperEval2D(float phi, float m, float n1, float n2, float n3, float a = 1, float b = 1)
    {
        float t1 = Mathf.Cos((m * phi) / 4f) / a;
        float t2 = Mathf.Sin((m * phi) / 4f) / b;
        float left = Mathf.Pow(Mathf.Abs(t1), n2);
        float right = Mathf.Pow(Mathf.Abs(t2), n3);

        float r = Mathf.Pow(left + right, -1 / n1);

        return r;
    }
    /// <summary>
    /// Convert a given local position to a 1D index for the byte array
    /// </summary>
    /// <param name="pos">A 3D point in local space</param>
    /// <param name="chunkSize">The world scale of the chunk</param>
    /// <returns>A integer index for the byte array</returns>
    public static int GetByteArrayIndex(Vector3 pos, Vector3Int chunkSize)
    {
        //IMPORTANT: This index is based on the loops in the byte array generation (NOTE: If chunk width = height = depth order of multiplication doesnt matter)
        //If order of loops is changed when generating the byte array and chunk dimensions are not all equal this equation needs to be updated
        return (int)pos.x + chunkSize.x * ((int)pos.y + chunkSize.y * (int)pos.z);
    }
    /// <summary>
    /// Convert a given 1D index to a 3D local position
    /// </summary>
    /// <param name="index">A byte array index</param>
    /// <param name="chunkSize">The world scale of the chunk</param>
    /// <returns>A 3D position in local space</returns>
    public static Vector3 GetPositionFromIndex(int index, Vector3Int chunkSize)
    {
        int z = index / (chunkSize.x * chunkSize.y);
        index -= (z * chunkSize.x * chunkSize.y);
        int y = index / chunkSize.x;
        int x = index % chunkSize.x;
        return new Vector3(x, y, z);
    }
    /// <summary>
    /// Generate a 3D layered noise value at the given world space position with the given settings.
    /// NOTE: Upper bound on noise value returned varies with noise settings.
    /// </summary>
    /// <param name="pos">A 3D position in world space</param>
    /// <param name="settings">A NoiseSettings struct containing the settings for the layered noise</param>
    /// <returns>A 3D layered noise value >= 0.0</returns>
    public static float LayeredNoise(Vector3 pos)
    {
        float x, y, z;
        x = pos.x;
        y = pos.y;
        z = pos.z;

        //settings.fastNoise.DomainWarp(ref x, ref y, ref z);
        // float noiseVal = (fastNoise.GetNoise(x,y,z) + 1) / 2f;
        //noiseVal *= Mathf.PerlinNoise(pos.x * settings.frequency / 2, pos.z * settings.frequency / 2) * 2;
        //return  Mathf.Max(0,noiseVal - settings.recede) * settings.strength;
        //float baseNoise = Mathf.PerlinNoise((pos.x + 1000f) / 60f, (pos.z + 1000f) / 60f);
        float perlin = Mathf.PerlinNoise((pos.x + 6000f) / 50f, (pos.z + 6000f) / 50f) * 2 - 1;
        perlin *= Mathf.PerlinNoise((pos.x + 1000f) / 50f, (pos.z + 1000f) / 50f);
        if(perlin < 0)
        {
            perlin = 0;
        }
        float biomeNoise = 75 * perlin;
        return biomeNoise;
    }
    //Container class for storing the chunk information (used to pass data between threads)
    //(Mesh vertices, triangles, arrays, world position, noise settings, saved data)
    public class ChunkData
    {
        public int LOD;
        public bool empty = true;
        public Vector3[] vertexArray;
        public int[] triangleArray;
        public Color[] colorArray;

        //3D chunk position relative to other chunks
        public Vector3Int chunkCoord;
        //3D chunk position in world space
        public Vector3 chunkWorldPos;
        //Chunk world scale
        public Vector3Int chunkSize;
        //Current noise settings
        public NoiseSettings settings;
        //A 1D array containing the byte values for each block in the chunk
        public byte[] byteArr;

        public bool jobComplete = false;

        //Saved chunk data object (contains dictionary of destroyed/placed blocks)
        public SavedChunkData savedData;
        public ChunkData(Vector3Int chunkCoord, Vector3 chunkWorldPos,  Vector3Int chunkSize, int byteArraySize, SavedChunkData savedData)
        {
            this.chunkCoord = chunkCoord;
            this.chunkWorldPos = chunkWorldPos;
            this.chunkSize = chunkSize;
            this.byteArr = new byte[byteArraySize];
            this.savedData = savedData;

        }
        /// <summary>
        /// Get the byte value at the given byte array index
        /// </summary>
        /// <param name="i">An integer index for the byte array</param>
        /// <returns>The byte value at index in the byte array</returns>
        public byte GetByteValue(int i)
        {
            Vector3Int pos = Vector3Int.FloorToInt(GetPositionFromIndex(i, chunkSize));
            if(savedData != null && savedData.HasByte(pos))
            {
                return savedData.GetByte(pos);
            }
            return byteArr[i];
        }
        public byte GetSurroundingByte(Vector3Int pos)
        {
            if (savedData != null && savedData.HasByte(pos))
            {
                return savedData.GetByte(pos);
            }
            return GenerateBlock(chunkWorldPos + pos);
        }
        public byte GetByteValue(Vector3Int pos)
        {
            int index = GetByteArrayIndex(pos, chunkSize);
            if (savedData != null && savedData.HasByte(pos))
            {
                return savedData.GetByte(pos);
            }
            return byteArr[index];
        }
        /// <summary>
        /// Set the byte value at the given byte array index to the given byte.
        /// </summary>
        /// <param name="i">An integer index for the byte array</param>
        /// <param name="b">The byte value to store in the array at the given index</param>
        public void SetByteValue(int i, byte b)
        {
            this.byteArr[i] = b;
            if(b != 0)
            {
                empty = false;
            }
        }
        /// <summary>
        /// Resets the chunk data to default values
        /// </summary>
        public void Reset()
        {
            jobComplete = false;
        }
    }
    //Container class for storing saved chunk information (blocks placed/destroyed)
    public class SavedChunkData
    {
        //Dictionary of saved bytes, where key = their 
        Dictionary<Vector3Int, byte> storedBytes = new Dictionary<Vector3Int, byte>();
        //3D chunk x,y,z index
        Vector3Int chunkPos;
        public SavedChunkData(Vector3Int chunkPos)
        {
            this.chunkPos = chunkPos;
        }
        /// <summary>
        /// Add a byte to the stored bytes dictionary at a given local position.
        /// </summary>
        /// <param name="pos">A 3D position in local space</param>
        /// <param name="b">The byte value to add</param>
        public void AddByte(Vector3Int pos, byte b)
        {
            //If the dictionary already has a block saved here update the value, else add the byte as a new value
            if (storedBytes.ContainsKey(pos))
            {
                storedBytes[pos] = b;
            }
            else
            {
                storedBytes.Add(pos, b);
            }
        }
        /// <summary>
        /// Get the byte at a given local position.
        /// </summary>
        /// <param name="pos">A 3D position in local space</param>
        /// <returns>The byte value at the given position (if position does not exist, return 0)</returns>
        public byte GetByte(Vector3Int pos)
        {
            //Verify the dictionary has a byte at this position, if it does return the value, else return 0
            if (HasByte(pos))
                return storedBytes[pos];
            return 0;
        }
        /// <summary>
        /// Determine if dictionary contains byte at given local position.
        /// </summary>
        /// <param name="pos">A 3D position in local space</param>
        /// <returns>true if byte value exists given local position, false otherwise</returns>
        public bool HasByte(Vector3Int pos)
        {
            return storedBytes.ContainsKey(pos);
        }
        /// <summary>
        /// Get the 3D chunk x,y,z index
        /// </summary>
        /// <returns>A 3D chunk index vector</returns>
        public Vector3Int GetChunkPos()
        {
            return this.chunkPos;
        }
    }
}
