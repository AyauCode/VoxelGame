using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Concurrent;

public class TerrainChunk : MonoBehaviour
{
    //A 3D chunk index
    public Vector3Int chunkCoord;
    //A 3D chunk position in world space
    public Vector3 chunkWorldPos;
    //Chunk world scale
    public Vector3Int chunkSize;

    //Mesh components
    MeshRenderer meshRenderer;
    MeshFilter meshFilter;
    MeshCollider meshCollider;
    Mesh mesh;

    //Chunk data container (used to pass chunk information between threads)
    ChunkData chunkData;

    //True if chunk mesh is generated, otherwise false
    public bool generated = false;

    void Awake()
    {
        //Get the mesh components from the chunk game object
        meshRenderer = GetComponent<MeshRenderer>();
        meshFilter = GetComponent<MeshFilter>();
        //meshCollider = GetComponent<MeshCollider>();
    }
    /// <summary>
    /// Get the local position of the given world space position relative to this chunk
    /// </summary>
    /// <param name="pos">A 3D point in World Space</param>
    /// <returns>A 3D point in local space (floored to integers)</returns>
    public Vector3Int GetLocalPosition(Vector3 pos)
    {
        return Vector3Int.FloorToInt(pos - this.chunkWorldPos);
    }
    /// <summary>
    /// Get the byte value at the given 3D point
    /// </summary>
    /// <param name="pos">A 3D point in world or local space</param>
    /// <param name="isLocalPoint">Pass true if pos parameter is in local space, otherwise false</param>
    /// <returns>The byte value of the block at the given position</returns>
    public byte GetBlockByteValue(Vector3Int pos, bool isLocalPoint)
    {
        //If we are a local point (i.e. 0 <= pos < scale in all directions)
        if (isLocalPoint)
        {
            //Get the byte value at the position
            byte outByte = chunkData.GetByteValue(GetByteArrayIndex(pos, chunkSize));

            //If the chunk has saved data at this position override the byte value generated by the terrain noise
            if (chunkData.savedData != null && chunkData.savedData.HasByte(pos))
            {
                outByte = chunkData.savedData.GetByte(pos);
            }
            return outByte;
        }
        else
        {
            //If we are here we are not a local point, convert the world space position to local space
            Vector3Int localPos = GetLocalPosition(pos);

            //Get the byte value a the local space position
            byte outByte = chunkData.GetByteValue(GetByteArrayIndex(localPos, chunkSize));

            //If the chunk has saved data at this position override the byte value generated by the terrain noise
            if(chunkData.savedData != null && chunkData.savedData.HasByte(localPos))
            {
                outByte = chunkData.savedData.GetByte(localPos);
            }
            return outByte;
        }
    }
    /// <summary>
    /// Check to see if any of this chunks worker threads have finished their tasks.
    /// If they have, complete them and dispose of the thread
    /// </summary>
    public void WaitForByteArray()
    {
        if(!generated && chunkData != null && chunkData.jobComplete)
        {
            Mesh chunkMesh = new Mesh();
            chunkMesh.vertices = chunkData.vertexArray;
            chunkMesh.triangles = chunkData.triangleArray;

            chunkMesh.RecalculateNormals();
            UpdateMesh(chunkMesh);

            generated = true;
        }
    }
    /// <summary>
    /// Clear the chunk of all current data, cancel any running threads, set chunk to be ungenerated
    /// </summary>
    public void ClearChunk()
    {
        generated = false;

        if (chunkData == null) return;
        chunkData.Clear();
    }
    CancellationTokenSource tokenSource;
    /// <summary>
    /// Begin generation of the chunk mesh.
    /// If chunk had previous data, clear it. Start thread to generate byte values at each block from octave noise.
    /// </summary>
    /// <param name="chunkCoord">A 3D chunk index</param>
    /// <param name="chunkWorldPos">A 3D chunk position in world space</param>
    /// <param name="settings">A NoiseSettings struct containing the values to use for the octave noise</param>
    /// <param name="savedData">The saved data for this chunk</param>
    public void GenerateChunk(Vector3Int chunkCoord, Vector3 chunkWorldPos, SavedChunkData savedData)
    {
        ClearChunk();
        this.chunkCoord = chunkCoord;
        this.chunkWorldPos = chunkWorldPos;

        chunkData = new ChunkData(chunkWorldPos, chunkSize, chunkSize.x * chunkSize.y * chunkSize.z, savedData);

        tokenSource = new CancellationTokenSource();
        chunkData.token = tokenSource.Token;
        ThreadPool.QueueUserWorkItem(new WaitCallback(FullGenerate), chunkData);
    }
    public void CancelThread()
    {
        if (!generated && tokenSource != null)
        {
            tokenSource.Cancel();
        }
    }
    public static void ThreadGenerate(object state)
    {
        ChunkData chunkData = (ChunkData)state;
        GenerateMesh(state);
        chunkData.jobComplete = true;
    }
    public static void FullGenerate(object state)
    {   
        ChunkData chunkData = (ChunkData)state;
        GenerateByteArray(chunkData);
        GenerateMesh(chunkData);
        chunkData.jobComplete = true;
    }
    /// <summary>
    /// Generate the byte values for a chunk.
    /// </summary>
    /// <param name="sender">The BackgroundWorker invoking this method</param>
    /// <param name="e">Parameter to share ChunkData object information between threads</param>
    public static void GenerateByteArray(object state)
    {
        //Get the chunk data from the worker argument passed on the method call.
        ChunkData chunkData = (ChunkData)state;

        //Loop over all local positions (in the x,y, and z directions)
        Vector3 pos = Vector3.zero;
        for(int i = 0; i < chunkData.chunkSize.x; i++)
        {
            for(int j = 0; j < chunkData.chunkSize.y; j++)
            {
                for(int k = 0; k < chunkData.chunkSize.z; k++)
                {
                    if (chunkData.token.IsCancellationRequested) { return; }
                    //Convert the 3D local space coordinate to an index to access a 1D array of byte values
                    pos.Set(i, j, k);
                    int index = GetByteArrayIndex(pos, chunkData.chunkSize);
                    //Generate the byte value at the world space position of the block, with current noise settings
                    //Set the byte value at the index, to the generated value
                    byte val = GenerateBlock(chunkData.chunkWorldPos + pos);
                    chunkData.SetByteValue(index, val);
                }
            }
        }
    }
    private static Mutex mutexLock = new Mutex();
    /// <summary>
    /// Generate the chunk mesh from the generate byte values
    /// </summary>
    /// <param name="sender">The BackgroundWorker invoking this method</param>
    /// <param name="e">Parameter to share ChunkData object information between threads</param>
    public static void GenerateMesh(object state)
    {
        //Get the chunk data from the worker argument passed on the method call.
        ChunkData chunkData = (ChunkData)state;
        
        if (chunkData.fillCount == 0) { return; }
        
        /*int blockCount = chunkData.chunkSize.x * chunkData.chunkSize.y * chunkData.chunkSize.z;
        Parallel.For(0, blockCount, index => {
            Vector3 pos = GetPositionFromIndex(index, chunkData.chunkSize);
            Vector3Int intPos = Vector3Int.FloorToInt(pos);

            //Check if saved block is actually an air block, if so continue to the next block
            if (chunkData.savedData != null && chunkData.savedData.HasByte(intPos) && chunkData.savedData.GetByte(intPos) == 1)
            {
                //Do Nothing
            }
            else if (chunkData.savedData != null && chunkData.savedData.HasByte(intPos) && chunkData.savedData.GetByte(intPos) == 0)
            {
                return;
            }
            else if (chunkData.byteArr[index] == 0)
            {
                return;
            }

            //If we are here then the current block is solid
            //Loop over each direction
            Parallel.For(0, CustomMath.NUMDIRECTIONS, dIndex =>
            {
               Vector3 dir = CustomMath.directions[dIndex];
                //Get the block adjacent to the current block in the given direction
                Vector3 surrounding = pos + dir;
                //Get the calculate adjacent vector as an integer vector
                Vector3Int surroundingInt = intPos + CustomMath.intDirections[dIndex];


                //If the calculated adjacent block is inside the bounds of this chunk continue into this if
                if (surrounding.x < chunkData.chunkSize.x && surrounding.x >= 0 && surrounding.y < chunkData.chunkSize.y && surrounding.y >= 0 && surrounding.z < chunkData.chunkSize.z && surrounding.z >= 0)
                {
                    //If the block adjacent to the current block is air then construct a cube face in its direction
                    if (chunkData.byteArr[GetByteArrayIndex(surrounding, chunkData.chunkSize)] == 0)
                    {
                        //Array of directions for constructing the cube face with quad normal = dir
                        Vector3[] wlDir = CustomMath.directionDictionary[dir];
                        //Add a quad to the current vertices and triangles of the chunk, with width and length relative to the quad normal
                        AddQuadConcurrent(chunkData.vertices, chunkData.triangles, pos + wlDir[2], wlDir[0], wlDir[1], dir);
                    }
                    //Else if the chunk has saved data at this adjacent block and its saved data is an air block construct a cube face in its direction
                    else if ((chunkData.savedData != null && chunkData.savedData.HasByte(surroundingInt) && chunkData.savedData.GetByte(surroundingInt) == 0))
                    {   
                        //Array of directions for constructing the cube face with quad normal = dir
                        Vector3[] wlDir = CustomMath.directionDictionary[dir];
                        //Add a quad to the current vertices and triangles of the chunk, with width and length relative to the quad normal
                        AddQuadConcurrent(chunkData.vertices, chunkData.triangles, pos + wlDir[2], wlDir[0], wlDir[1], dir);
                    }
                }
                //Else if the block is outside the current chunk bounds quickly generate the value the block would have in the next chunk
                //Or if the chunk has saved data about the adjacent block outside the bounds and that block is air construct a face in its direction
                //NOTE: the chunk saved data will contain information about blocks outside of the chunk bounds due to how saved information is added to the chunks
                else if (GenerateBlock(chunkData.chunkWorldPos + surrounding) == 0 || (chunkData.savedData != null && chunkData.savedData.HasByte(surroundingInt) && chunkData.savedData.GetByte(surroundingInt) == 0))
                {
                    //Array of directions for constructing the cube face with quad normal = dir
                    Vector3[] wlDir = CustomMath.directionDictionary[dir];
                    //Add a quad to the current vertices and triangles of the chunk, with width and length relative to the quad normal
                    AddQuadConcurrent(chunkData.vertices, chunkData.triangles, pos + wlDir[2], wlDir[0], wlDir[1], dir);
                }
            });

        });
        */
        
        //Loop over all local space positions
        Vector3 pos = Vector3.zero;
        Vector3Int intPos = Vector3Int.zero;
        for (int i = 0; i < chunkData.chunkSize.x; i++)
        {
            for (int k = 0; k < chunkData.chunkSize.z; k++)
            {
                for (int j = 0; j < chunkData.chunkSize.y; j++)
                {
                    if(chunkData.token.IsCancellationRequested) { return; }
                    pos.Set(i, j, k);
                    intPos.Set(i, j, k);

                    //Check if saved block is actually an air block, if so continue to the next block
                    if(chunkData.savedData != null && chunkData.savedData.HasByte(intPos) && chunkData.savedData.GetByte(intPos) == 1)
                    {
                        //Do Nothing
                    }
                    else if(chunkData.savedData != null && chunkData.savedData.HasByte(intPos) && chunkData.savedData.GetByte(intPos) == 0)
                    {
                        continue;
                    }
                    else if (chunkData.byteArr[GetByteArrayIndex(pos, chunkData.chunkSize)] == 0)
                    {
                        continue;
                    }

                    //If we are here then the current block is solid
                    //Loop over each direction
                    for (int dIndex = 0; dIndex < CustomMath.NUMDIRECTIONS; dIndex++)
                    {
                        Vector3 dir = CustomMath.directions[dIndex];
                        //Get the block adjacent to the current block in the given direction
                        Vector3 surrounding = pos + dir;
                        //Get the calculate adjacent vector as an integer vector
                        Vector3Int surroundingInt = intPos + CustomMath.intDirections[dIndex];

                        
                        //If the calculated adjacent block is inside the bounds of this chunk continue into this if
                        if (surrounding.x < chunkData.chunkSize.x && surrounding.x >= 0 && surrounding.y < chunkData.chunkSize.y && surrounding.y >= 0 && surrounding.z < chunkData.chunkSize.z && surrounding.z >= 0)
                        {
                            //If the block adjacent to the current block is air then construct a cube face in its direction
                            if (chunkData.byteArr[GetByteArrayIndex(surrounding, chunkData.chunkSize)] == 0)
                            {
                                //Array of directions for constructing the cube face with quad normal = dir
                                Vector3[] wlDir = CustomMath.directionDictionary[dir];
                                //Add a quad to the current vertices and triangles of the chunk, with width and length relative to the quad normal
                                AddQuad(chunkData.vertices, chunkData.triangles, pos + wlDir[2], wlDir[0], wlDir[1], dir);
                            }
                            //Else if the chunk has saved data at this adjacent block and its saved data is an air block construct a cube face in its direction
                            else if((chunkData.savedData != null && chunkData.savedData.HasByte(surroundingInt) && chunkData.savedData.GetByte(surroundingInt) == 0))
                            {
                                //Array of directions for constructing the cube face with quad normal = dir
                                Vector3[] wlDir = CustomMath.directionDictionary[dir];
                                //Add a quad to the current vertices and triangles of the chunk, with width and length relative to the quad normal
                                AddQuad(chunkData.vertices, chunkData.triangles, pos + wlDir[2], wlDir[0], wlDir[1], dir);
                            }
                        }
                        //Else if the block is outside the current chunk bounds quickly generate the value the block would have in the next chunk
                        //Or if the chunk has saved data about the adjacent block outside the bounds and that block is air construct a face in its direction
                        //NOTE: the chunk saved data will contain information about blocks outside of the chunk bounds due to how saved information is added to the chunks
                        else if(GenerateBlock(chunkData.chunkWorldPos + surrounding) == 0 || (chunkData.savedData != null && chunkData.savedData.HasByte(surroundingInt) && chunkData.savedData.GetByte(surroundingInt) == 0))
                        {
                            //Array of directions for constructing the cube face with quad normal = dir
                            Vector3[] wlDir = CustomMath.directionDictionary[dir];
                            //Add a quad to the current vertices and triangles of the chunk, with width and length relative to the quad normal
                            AddQuad(chunkData.vertices, chunkData.triangles, pos + wlDir[2], wlDir[0], wlDir[1], dir);
                        }
                    }
                }
            }
        }

        //Convert the vertex and triangle list to arrays (as Mesh object only takes arrays)
        //This is done in the separate thread to offload more work from the main thread
        chunkData.vertexArray = chunkData.vertices.ToArray();
        chunkData.triangleArray = chunkData.triangles.ToArray();
    }
    /// <summary>
    /// Set the chunk mesh filter and collider to use the given mesh
    /// </summary>
    /// <param name="mesh">A completed chunk mesh</param>
    void UpdateMesh(Mesh mesh)
    {
        this.mesh = mesh;
        meshFilter.sharedMesh = mesh;
        //meshCollider.sharedMesh = mesh;
    }
    /// <summary>
    /// Adds vertices and triangle indices for a quad to the given vertex/triangle list
    /// </summary>
    /// <param name="vertices">A list of vertices of the chunk mesh</param>
    /// <param name="triangles">A list of triangle indices of the chunk mesh</param>
    /// <param name="pos">A 3D point in world space (bottom left corner of the quad)</param>
    /// <param name="widthDir">Direction of width for quad</param>
    /// <param name="lengthDir">Direction of length for quad</param>
    /// <param name="normal">Normal vector of quad face</param>
    public static void AddQuad(List<Vector3> vertices, List<int> triangles, Vector3 pos, Vector3 widthDir, Vector3 lengthDir, Vector3 normal)
    {
        //mutexLock.WaitOne();
        //Calculate top and bottom left, right vertex positions based on given direction vectors
        Vector3 vBottomLeft = Vector3.zero, vBottomRight = Vector3.zero, vTopLeft = Vector3.zero, vTopRight = Vector3.zero;
        vBottomLeft = pos;
        vBottomRight = pos + widthDir;
        vTopLeft = pos + lengthDir;
        vTopRight = pos + widthDir + lengthDir;

        //If normal vector is left or forward flip the triangle to render on correct side (related to winding order)
        int vIndex = vertices.Count;
        if (normal == Vector3.left || normal == Vector3.forward || normal == Vector3.down)
        {
            //Add the triangle indices to the list in a counter-clockwise order
            triangles.Add(vIndex);
            triangles.Add(vIndex + 1);
            triangles.Add(vIndex + 2);

            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 1);
            triangles.Add(vIndex + 3);
        }
        else
        {
            //Add the triangle indices to the list in a clockwise order
            triangles.Add(vIndex);
            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 1);

            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 3);
            triangles.Add(vIndex + 1);
        }

        //Add the calculated vertices to the vertex list
        vertices.Add(vBottomLeft);
        vertices.Add(vBottomRight);
        vertices.Add(vTopLeft);
        vertices.Add(vTopRight);

        //mutexLock.ReleaseMutex();
    }
    public static void AddQuadConcurrent(List<Vector3> vertices, List<int> triangles, Vector3 pos, Vector3 widthDir, Vector3 lengthDir, Vector3 normal)
    {
        //Calculate top and bottom left, right vertex positions based on given direction vectors
        Vector3 vBottomLeft = Vector3.zero, vBottomRight = Vector3.zero, vTopLeft = Vector3.zero, vTopRight = Vector3.zero;
        vBottomLeft = pos;
        vBottomRight = pos + widthDir;
        vTopLeft = pos + lengthDir;
        vTopRight = pos + widthDir + lengthDir;

        //If normal vector is left or forward flip the triangle to render on correct side (related to winding order)
        mutexLock.WaitOne();
        int vIndex = vertices.Count;
        if (normal == Vector3.left || normal == Vector3.forward || normal == Vector3.down)
        {
            //Add the triangle indices to the list in a counter-clockwise order
            triangles.Add(vIndex);
            triangles.Add(vIndex + 1);
            triangles.Add(vIndex + 2);

            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 1);
            triangles.Add(vIndex + 3);
        }
        else
        {
            //Add the triangle indices to the list in a clockwise order
            triangles.Add(vIndex);
            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 1);

            triangles.Add(vIndex + 2);
            triangles.Add(vIndex + 3);
            triangles.Add(vIndex + 1);
        }

        //Add the calculated vertices to the vertex list
        vertices.Add(vBottomLeft);
        vertices.Add(vBottomRight);
        vertices.Add(vTopLeft);
        vertices.Add(vTopRight);

        mutexLock.ReleaseMutex();
    }
    /// <summary>
    /// Generate the byte value at the given world position with the current NoiseSettings
    /// </summary>
    /// <param name="pos">A 3D point in world space</param>
    /// <param name="settings">A NoiseSettings struct containing the settings for the octave noise</param>
    /// <returns>A byte value (0 for air, 1 for a solid block)</returns>
    public static byte GenerateBlock(Vector3 pos)
    {
        byte output = 0;
        //Get layered noise value at the world position with current settings, subtracting block pos.y
        //NOTE: subtracting pos.y is done to create a flat plane near y = 0
        //float val = -pos.y + LayeredNoise(pos, settings, settings.fastNoise);
        float val = -pos.y + LayeredNoise(pos);
        //If the value is greater than the air block cutoff it is a solid block (set the output to 1)
        if(val > 70f)
        {
            output = 1;
        }
        
        return output;
    }
    static bool SuperEval3D(float m, float n1, float n2, float n3, float x, float y, float z, float size, float error)
    {
        y -= 20f;
        z -= 20f;
        float pointR = Mathf.Sqrt(x * x + y * y + z * z);
        float theta = Mathf.Atan2(y, x);
        float phi = Mathf.Asin(z / (pointR));

        float r1 = SuperEval2D(theta, 5,0.1f,1.7f,1.7f);
        float r2 = SuperEval2D(phi, 1,0.3f,0.5f,0.5f);

        float x1 = (r1 * Mathf.Cos(theta) * r2 * Mathf.Cos(phi) * size);
        float y1 = (r1 * Mathf.Sin(theta) * r2 * Mathf.Cos(phi) * size);
        float z1 = (r2 * Mathf.Sin(phi) * size);
        float r = Mathf.Sqrt(x1 * x1 + y1 * y1 + z1 * z1);

        return pointR < r;
    }
    static float SuperEval2D(float phi, float m, float n1, float n2, float n3, float a = 1, float b = 1)
    {
        float t1 = Mathf.Cos((m * phi) / 4f) / a;
        float t2 = Mathf.Sin((m * phi) / 4f) / b;
        float left = Mathf.Pow(Mathf.Abs(t1), n2);
        float right = Mathf.Pow(Mathf.Abs(t2), n3);

        float r = Mathf.Pow(left + right, -1 / n1);

        return r;
    }
    /// <summary>
    /// Convert a given local position to a 1D index for the byte array
    /// </summary>
    /// <param name="pos">A 3D point in local space</param>
    /// <param name="chunkSize">The world scale of the chunk</param>
    /// <returns>A integer index for the byte array</returns>
    public static int GetByteArrayIndex(Vector3 pos, Vector3Int chunkSize)
    {
        //IMPORTANT: This index is based on the loops in the byte array generation (NOTE: If chunk width = height = depth order of multiplication doesnt matter)
        //If order of loops is changed when generating the byte array and chunk dimensions are not all equal this equation needs to be updated
        return (int)pos.x + chunkSize.x * ((int)pos.y + chunkSize.y * (int)pos.z);
    }
    /// <summary>
    /// Convert a given 1D index to a 3D local position
    /// </summary>
    /// <param name="index">A byte array index</param>
    /// <param name="chunkSize">The world scale of the chunk</param>
    /// <returns>A 3D position in local space</returns>
    public static Vector3 GetPositionFromIndex(int index, Vector3Int chunkSize)
    {
        int z = index / (chunkSize.x * chunkSize.y);
        index -= (z * chunkSize.x * chunkSize.y);
        int y = index / chunkSize.x;
        int x = index % chunkSize.x;
        return new Vector3(x, y, z);
    }
    /// <summary>
    /// Generate a 3D layered noise value at the given world space position with the given settings.
    /// NOTE: Upper bound on noise value returned varies with noise settings.
    /// </summary>
    /// <param name="pos">A 3D position in world space</param>
    /// <param name="settings">A NoiseSettings struct containing the settings for the layered noise</param>
    /// <returns>A 3D layered noise value >= 0.0</returns>
    public static float LayeredNoise(Vector3 pos)
    {
        float x, y, z;
        x = pos.x;
        y = pos.y;
        z = pos.z;

        //settings.fastNoise.DomainWarp(ref x, ref y, ref z);
        // float noiseVal = (fastNoise.GetNoise(x,y,z) + 1) / 2f;
        //noiseVal *= Mathf.PerlinNoise(pos.x * settings.frequency / 2, pos.z * settings.frequency / 2) * 2;
        //return  Mathf.Max(0,noiseVal - settings.recede) * settings.strength;
        //float baseNoise = Mathf.PerlinNoise((pos.x + 1000f) / 60f, (pos.z + 1000f) / 60f);
        float biomeNoise = 60 * Mathf.Clamp(Mathf.PerlinNoise((pos.x + 6000f) / 50f, (pos.z + 6000f) / 50f)*1.5f, 0.5f, 2f);
        return biomeNoise;
    }
    //Container class for storing the chunk information (used to pass data between threads)
    //(Mesh vertices, triangles, arrays, world position, noise settings, saved data)
    public class ChunkData
    {
        public CancellationToken token;
        public int fillCount = 0;
        //List of vertex positions for the chunk mesh
        public List<Vector3> vertices = new List<Vector3>();
        //List of triangle indices for the chunk mesh
        public List<int> triangles = new List<int>();

        //Array representations of vertex/triangle lists
        public Vector3[] vertexArray;
        public int[] triangleArray;

        //3D chunk position in world space
        public Vector3 chunkWorldPos;
        //Chunk world scale
        public Vector3Int chunkSize;
        //Current noise settings
        public NoiseSettings settings;
        //A 1D array containing the byte values for each block in the chunk
        public byte[] byteArr;

        public bool jobComplete = false;

        //Saved chunk data object (contains dictionary of destroyed/placed blocks)
        public SavedChunkData savedData;
        public ChunkData(Vector3 chunkWorldPos,  Vector3Int chunkSize, int byteArraySize, SavedChunkData savedData)
        {
            this.chunkWorldPos = chunkWorldPos;
            this.chunkSize = chunkSize;
            this.byteArr = new byte[byteArraySize];
            this.savedData = savedData;
        }
        /// <summary>
        /// Get the byte value at the given byte array index
        /// </summary>
        /// <param name="i">An integer index for the byte array</param>
        /// <returns>The byte value at index in the byte array</returns>
        public byte GetByteValue(int i)
        {
            return byteArr[i];
        }
        /// <summary>
        /// Set the byte value at the given byte array index to the given byte.
        /// </summary>
        /// <param name="i">An integer index for the byte array</param>
        /// <param name="b">The byte value to store in the array at the given index</param>
        public void SetByteValue(int i, byte b)
        {
            this.byteArr[i] = b;
            this.fillCount += (int)(b);
        }
        /// <summary>
        /// Clears the vertex and triangle list
        /// </summary>
        public void Clear()
        {
            jobComplete = false;
            vertices.Clear();
            triangles.Clear();
        }
    }
    //Container class for storing saved chunk information (blocks placed/destroyed)
    public class SavedChunkData
    {
        //Dictionary of saved bytes, where key = their 
        Dictionary<Vector3Int, byte> storedBytes = new Dictionary<Vector3Int, byte>();
        //3D chunk x,y,z index
        Vector3Int chunkPos;
        public SavedChunkData(Vector3Int chunkPos)
        {
            this.chunkPos = chunkPos;
        }
        /// <summary>
        /// Add a byte to the stored bytes dictionary at a given local position.
        /// </summary>
        /// <param name="pos">A 3D position in local space</param>
        /// <param name="b">The byte value to add</param>
        public void AddByte(Vector3Int pos, byte b)
        {
            //If the dictionary already has a block saved here update the value, else add the byte as a new value
            if (storedBytes.ContainsKey(pos))
            {
                storedBytes[pos] = b;
            }
            else
            {
                storedBytes.Add(pos, b);
            }
        }
        /// <summary>
        /// Get the byte at a given local position.
        /// </summary>
        /// <param name="pos">A 3D position in local space</param>
        /// <returns>The byte value at the given position (if position does not exist, return 0)</returns>
        public byte GetByte(Vector3Int pos)
        {
            //Verify the dictionary has a byte at this position, if it does return the value, else return 0
            if (HasByte(pos))
                return storedBytes[pos];
            return 0;
        }
        /// <summary>
        /// Determine if dictionary contains byte at given local position.
        /// </summary>
        /// <param name="pos">A 3D position in local space</param>
        /// <returns>true if byte value exists given local position, false otherwise</returns>
        public bool HasByte(Vector3Int pos)
        {
            return storedBytes.ContainsKey(pos);
        }
        /// <summary>
        /// Get the 3D chunk x,y,z index
        /// </summary>
        /// <returns>A 3D chunk index vector</returns>
        public Vector3Int GetChunkPos()
        {
            return this.chunkPos;
        }
    }
}
